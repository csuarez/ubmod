#!/usr/bin/env perl
use strict;
use warnings;
use Carp;
use FindBin;
use lib "$FindBin::Bin/../lib";
use DBI;
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use Config::Tiny;
use DateTime;
use Ubmod::Aggregator;
use Ubmod::Logger;

# Global variables
my $Dbh;
my $Logger;
my $Format;

sub main {
    my ($options) = @_;

    if ( $options->{help} ) {
        pod2usage( -exitval => 0, -verbose => 2 );
    }

    $Logger = Ubmod::Logger->new( $options->{verbose} );

    my $config = Config::Tiny->read("$FindBin::Bin/../config/settings.ini");
    db_connect( @{ $config->{database} }{qw( host dbname user password )} );

    if ( $options->{shred} ) {

        if ( !$options->{format} ) {
            $Logger->fatal("No input format specified.");
            exit 1;
        }
        elsif ( $options->{format} !~ /^\w+$/ ) {
            $Logger->fatal("Invalid input format specified.");
            exit 1;
        }

        $Format = lc $options->{format};
        my $shredder_class = 'Ubmod::Shredder::' . ucfirst $Format;

        if ( !eval("require $shredder_class") ) {
            $Logger->fatal("Unknown input format specified.");
            exit 1;
        }

        my $shredder = $shredder_class->new( logger => $Logger );

        $shredder->set_host( $options->{host} ) if defined $options->{host};

        $Logger->info("Shredding.");

        my $count;
        if ( $options->{dir} ) {
            $count = process_directory( $shredder, $options->{dir} );
        }
        elsif ( $options->{file} ) {
            $count = process_file( $shredder, $options->{file} );
        }
        elsif ( $options->{stdio} ) {
            $Logger->info("Processing standard input.");
            $count = process_fh( $shredder, *STDIN );
        }
        else {
            $Logger->fatal("No input source specified.");
            pod2usage( -exitval => 1, -verbose => 1 );
        }

        $Logger->info("Total shredded: $count");
        $Logger->info("Done shredding!");

        transform_data($shredder);
    }

    if ( $options->{update} ) {
        $Logger->info("Updating aggregate tables.");

        my %agg_opts = ( dbh => $Dbh, logger => $Logger );

        if ( defined $options->{end_date} ) {
            if ( $options->{end_date} =~ /^(\d{4})-(\d{1,2})-(\d{1,2})$/ ) {
                my $date = eval {
                    DateTime->new( year => $1, month => $2, day => $3 );
                };
                if ( !$date ) {
                    $Logger->fatal("Invalid date: '$options->{end_date}'");
                    exit 1;
                }
                $agg_opts{end_date} = $date;
            }
            else {
                $Logger->fatal("Invalid date format: '$options->{end_date}'");
                exit 1;
            }
        }

        my $aggregator = Ubmod::Aggregator->new(%agg_opts);

        eval { $aggregator->aggregate(); };
        if ($@) {
            $Logger->fatal("Failed to update aggregate tables!");
            exit 1;
        }

        $Logger->info("Done updating aggregate tables!");
    }

    if ( !$options->{update} && !$options->{shred} ) {
        $Logger->fatal('No shredding or updating option was specified');
        pod2usage( -exitval => 1, -verbose => 1 );
    }
}

sub process_directory {
    my ( $shredder, $dir ) = @_;

    $Logger->info( "Processing files for host: " . $shredder->host() )
        if $shredder->has_host();
    $Logger->info("Processing directory: $dir");

    if ( !-d $dir ) {
        $Logger->fatal("Cannot access '$dir': No such directory");
        exit 1;
    }

    my @files;
    if ( my $date = get_event_max_date( $shredder->host() ) ) {
        $Logger->info("Shredding files dated after $date.");
        @files = @{ get_file_names( $dir, $date ) };
    }
    else {
        $Logger->info('Empty database, shredding all files.');
        @files = @{ get_file_names($dir) };
    }

    # Prepend directory path
    @files = map { File::Spec->catfile( $dir, $_ ) } @files;

    return process_files( $shredder, \@files );
}

sub process_files {
    my ( $shredder, $files ) = @_;

    my $record_count = 0;
    my $file_count   = 0;

    foreach my $file (@$files) {
        if ( !-e $file ) {
            $Logger->warn("File not found '$file'.");
            next;
        }
        if ( !-f $file ) {
            $Logger->warn("Skipping non-file '$file'.");
            next;
        }
        if ( !-r $file ) {
            $Logger->warn("Skipping unreadable file '$file'.");
            next;
        }

        $record_count += process_file( $shredder, $file );
        $file_count++;
    }

    $Logger->info("Shredded $file_count files.");

    return $record_count;
}

sub process_file {
    my ( $shredder, $file ) = @_;

    $Logger->info("Processing file: $file");

    if ( !-f $file ) {
        $Logger->fatal("Cannot access '$file': No such file");
        exit 1;
    }

    my $fh;
    if ( !open $fh, '<', $file ) {
        $Logger->fatal("Could not open file '$file': $!");
        exit 1;
    }

    return process_fh( $shredder, $fh );
}

sub process_fh {
    my ( $shredder, $fh ) = @_;

    my $count = 0;
    while ( defined( my $line = readline($fh) ) ) {
        my $event = eval { $shredder->shred($line); };
        if ($@) {
            $Logger->fatal($@);
            next;
        }

        # Skip empty events
        next unless %$event;

        insert_native_event($event);
        $count++;
    }

    $Logger->info("Shredded $count records.");

    return $count;
}

sub db_connect {
    my ( $host, $dbname, $user, $pass ) = @_;

    my $dsn = "DBI:mysql:host=$host;database=$dbname";

    $Dbh = eval {
        DBI->connect( $dsn, $user, $pass,
            { PrintError => 0, RaiseError => 1, AutoCommit => 1 } );
    };
    if ($@) {
        $Logger->fatal("Failed to connect to database: $@");
        exit 1;
    }
}

sub insert_native_event {
    my ($event) = @_;

    my $sql = qq[ INSERT INTO ${Format}_event SET ];
    my @pairs = map {qq[ `$_` = ? ]} keys %$event;
    $sql .= join( ',', @pairs );
    my $sth = $Dbh->prepare($sql);
    $sth->execute( values %$event );

    return $Dbh->{mysql_insertid};
}

sub insert_host_log {
    my ($log) = @_;
    my $sth = $Dbh->prepare(
        q{
            INSERT INTO host_log SET
                event_id = ?,
                host = ?,
                cpu = ?
        }
    );
    $sth->execute( @$log{qw( event_id host cpu )} );
}

sub get_event_max_date {
    my ($host) = @_;

    my $sql = q{
        SELECT DATE_FORMAT( MAX(date_key), '%Y-%m-%d' )
        FROM event
    };

    $sql .= " WHERE cluster = " . $Dbh->quote($host) if defined $host;

    return $Dbh->selectrow_arrayref($sql)->[0];
}

sub get_file_names {
    my ( $dir, $date ) = @_;

    my $today = DateTime->now( time_zone => 'local' );
    $today->set(
        hour   => 0,
        minute => 0,
        second => 0,
    );

    if ( !defined $date ) {

        # If no date is specified return all files in the directory
        # excluding the file for today.

        my $dh;
        if ( !opendir $dh, $dir ) {
            $Logger->fatal("Could not open dir '$dir': $!");
            exit 1;
        }
        my @files = sort readdir($dh);

        # Skip hidden files
        @files = grep { !/^\./ } @files;

        # Remove file for today
        my $today_file = $today->strftime('%Y%m%d');
        @files = grep { $_ ne $today_file } @files;

        return \@files;
    }
    elsif ( $date =~ /^(\d{4})-(\d{2})-(\d{2})$/ ) {

        # If a date is specified return all files in the directory dated
        # after that date and before today.

        my $current = DateTime->new(
            year  => $1,
            month => $2,
            day   => $3,
        );
        $current->add( days => 1 );

        my @files;

        while ( DateTime->compare( $current, $today ) < 0 ) {
            push @files, $current->strftime('%Y%m%d');
            $current->add( days => 1 );
        }

        # Remove nonexistent files
        @files = grep { -f File::Spec->catfile( $dir, $_ ) } @files;

        return \@files;
    }
    else {
        $Logger->fatal("Invalid date format: '$date'");
        exit 1;
    }
}

sub transform_data {
    my ($shredder) = @_;

    # XXX move this somewhere else or limit the events that are
    # transformed by the query below
    $Dbh->do(q{ TRUNCATE event });

    my $sql = $shredder->get_transform_query();
    return $Dbh->do($sql);
}

# Using case-sensitive options because -H and -h are distinct.
Getopt::Long::Configure('no_ignore_case');

my %options;

GetOptions(
    ''             => \$options{stdio},
    'in|i=s'       => \$options{file},
    'dir|d=s'      => \$options{dir},
    'host|H=s'     => \$options{host},
    'shred|s'      => \$options{shred},
    'format|f=s'   => \$options{format},
    'end-date|e=s' => \$options{end_date},
    'update|u'     => \$options{update},
    'verbose|v'    => \$options{verbose},
    'help|h'       => \$options{help},
) or croak "Invalid options: $!";

main( \%options );

__END__

=head1 NAME

ubmod-shredder - UBMoD shredder script

=head1 VERSION

Version: $Id$

=head1 SYNOPSIS

B<ubmod-shredder> [B<-v>] [B<-u>] [B<-s>] [B<-H> I<host>] [B<-f> I<format>] [B<-i> I<file>|B<-d> I<dir>]

=head1 OPTIONS

=head2 GENERAL OPTIONS

=over 8

=item B<-s>, B<--shred>

Shred accounting file(s).

=item B<-u>, B<--update>

Update aggregate tables.

=item B<-v>, B<--verbose>

Increase verbosity.

=item B<-h>, B<--help>

Display this text and exit.

=back

=head2 SHREDDING OPTIONS

These options may be used with the C<-s> or C<--shred> option.

=over 8

=item B<-f>, B<--format> I<format>

Specify accounting file format (pbs or sge).

=item B<-H>, B<--host> I<hostname>

Explicitly set host from which the log file(s) originated.

=item B<-i>, B<--in> I<file>

Specify input file.

=item B<-d>, B<--dir> I<directory>

Specify accounting log directory. This option assumes that file names in
the directory are formatted as YYYYMMDD. The file for the current day
will be ignored.

=item B<->

A lone dash C<-> indicates standard input should be used.

=back

=head2 AGGREGATION OPTIONS

These options may be used with the C<-u> or C<--update> option.

=over 8

=item B<-e>, B<--end-date> I<date>

Explicitly set the end date used for aggregation time intervals. The
date must be in YYYY-MM-DD format. Defaults to yesterday.

=back

=head1 DESCRIPTION

This script can be used to parse and aggregate accounting data for use
with the UBMoD portal.

=head1 EXAMPLES

  ubmod-shredder -s --format pbs -d /var/spool/pbs/server_priv/accounting

  ubmod-shredder -s --format sge -i /var/lib/gridengine/default/common/accounting

  ubmod-shredder -u

  ubmod-shredder -h

=head1 AUTHOR

Jeffrey T. Palmer <jtpalmer@ccr.buffalo.edu>

=head1 COPYRIGHT AND LICENSE

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

The Original Code is UBMoD.

The Initial Developer of the Original Code is Research Foundation of State
University of New York, on behalf of University at Buffalo.

Portions created by the Initial Developer are Copyright (C) 2007 Research
Foundation of State University of New York, on behalf of University at
Buffalo.  All Rights Reserved.

=cut
